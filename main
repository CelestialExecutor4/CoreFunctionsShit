--[[ 
   ______     __          __  _       __
  / ____/__  / /__  _____/ /_(_)___ _/ /
 / /   / _ \/ / _ \/ ___/ __/ / __ `/ / 
/ /___/  __/ /  __(__  ) /_/ / /_/ / /  
\____/\___/_/\___/____/\__/_/\__,_/_/   
          [ Custom Functions ]                     
]]

-- is loaded
if getgenv().Is_Executor_Loaded == "true" then
    warn("Executor is already loaded!")
    return
else
    warn("Loading InitFunctions..")
end

-- Set flag
getgenv().Is_Executor_Loaded = "false"

-- metadata
local CelestialVersion = "1.1.4"
local Celestial = {
    about = {
        _name = 'Celestial',
        _version = CelestialVersion,
        _publisher = "Elemental Softworks"
    }
}
table.freeze(Celestial.about)  -- freeze

-- load core funcs
local function loadCoreFunctions()
    local TweenService = game:GetService("TweenService")

getgenv().Notify = function(titleText, messageText, displayTime, options, buttonText, buttonCallback)
    options = options or {}

    local titleColor = options.titleColor or Color3.fromRGB(255, 255, 255)
    local messageColor = options.messageColor or Color3.fromRGB(255, 255, 255)
    local buttonColor = options.buttonColor or Color3.fromRGB(0, 122, 255)  -- Blue button color
    local buttonTextColor = options.buttonTextColor or Color3.fromRGB(255, 255, 255)
    local backgroundDecal = options.backgroundDecal  -- New backgroundDecal option

    local GUI = Instance.new("ScreenGui")
    local Main = Instance.new("Frame", GUI)
    local title = Instance.new("TextLabel", Main)
    local message = Instance.new("TextLabel", Main)
    local closeButton = nil

    GUI.Name = "NotificationGUI"
    GUI.Parent = game.CoreGui

    Main.Name = "MainFrame"
    Main.BackgroundTransparency = 1  -- No background color, only the decal will be used
    Main.BorderSizePixel = 0
    Main.Position = UDim2.new(1, 5, 0, 50)
    Main.Size = UDim2.new(0, 350, 0, 120)
    Main.ClipsDescendants = true

    -- Apply the corner radius to the Main frame
    local corner = Instance.new("UICorner", Main)
    corner.CornerRadius = UDim.new(0, 10)

    -- Set the background decal if provided
    if backgroundDecal then
        -- Create the ImageLabel with the decal as the background
        local decal = Instance.new("ImageLabel", Main)
        decal.Name = "BackgroundDecal"
        decal.Size = UDim2.new(1, 0, 1, 0)  -- Fill the entire frame
        decal.Position = UDim2.new(0, 0, 0, 0)  -- Align with the frame
        decal.BackgroundTransparency = 1
        decal.Image = "rbxassetid://" .. tostring(backgroundDecal)
        decal.ZIndex = 0  -- Ensure the decal is in the background
    end

    title.Name = "Title"
    title.BackgroundTransparency = 1
    title.Size = UDim2.new(1, 0, 0, 35)
    title.Font = Enum.Font.GothamBold
    title.Text = titleText
    title.TextColor3 = titleColor
    title.TextSize = 24
    title.TextWrapped = true
    title.TextXAlignment = Enum.TextXAlignment.Left
    title.Position = UDim2.new(0, 10, 0, 5)
    title.ZIndex = 2  -- Ensure the title is above the background

    message.Name = "Message"
    message.BackgroundTransparency = 1
    message.Size = UDim2.new(1, -20, 1, -40)
    message.Position = UDim2.new(0, 10, 0, 40)
    message.Font = Enum.Font.Gotham
    message.Text = messageText
    message.TextColor3 = messageColor
    message.TextSize = 18
    message.TextWrapped = true
    message.TextXAlignment = Enum.TextXAlignment.Left
    message.TextYAlignment = Enum.TextYAlignment.Top
    message.ZIndex = 2  -- Ensure the message is above the background

    -- Optional button creation (raised it a bit higher)
    if buttonText and buttonCallback then
        local button = Instance.new("TextButton", Main)
        button.Name = "Button"
        button.Size = UDim2.new(1, -20, 0, 40)
        button.Position = UDim2.new(0, 10, 0, 70)  -- Raised position
        button.BackgroundColor3 = buttonColor
        button.TextColor3 = buttonTextColor
        button.Text = buttonText
        button.Font = Enum.Font.GothamBold
        button.TextSize = 18
        button.TextWrapped = true
        button.TextXAlignment = Enum.TextXAlignment.Center
        button.TextYAlignment = Enum.TextYAlignment.Center
        button.ZIndex = 2  -- Ensure the button is above the background

        button.MouseButton1Click:Connect(function()
            buttonCallback()
            GUI:Destroy()  -- Close the notification after button click
        end)
    end

    -- Add the close "X" button
    closeButton = Instance.new("TextButton", Main)
    closeButton.Name = "CloseButton"
    closeButton.Size = UDim2.new(0, 30, 0, 30)
    closeButton.Position = UDim2.new(1, -40, 0, 10)  -- Positioned at top-right
    closeButton.BackgroundTransparency = 1
    closeButton.Text = "X"
    closeButton.TextColor3 = Color3.fromRGB(255, 0, 0)  -- Red color for the close button
    closeButton.TextSize = 24
    closeButton.Font = Enum.Font.GothamBold
    closeButton.ZIndex = 2  -- Ensure the close button is above the background

    closeButton.MouseButton1Click:Connect(function()
        -- Close the notification with a smooth animation
        local closeTween = TweenService:Create(Main, TweenInfo.new(0.4, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {Position = UDim2.new(1, 5, 0, 50)})
        closeTween:Play()
        wait(0.4)
        GUI:Destroy()  -- Destroy the notification after the animation
    end)

    -- Hover effect to show the close button
    Main.MouseEnter:Connect(function()
        closeButton.Visible = true
    end)

    Main.MouseLeave:Connect(function()
        closeButton.Visible = false
    end)

    -- Animation setup for opening the UI (smooth transition)
    local openPosition = UDim2.new(1, -360, 0, 50)
    local closePosition = UDim2.new(1, 5, 0, 50)
    
    local openTween = TweenService:Create(Main, TweenInfo.new(0.6, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Position = openPosition})
    local closeTween = TweenService:Create(Main, TweenInfo.new(0.6, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {Position = closePosition})

    -- Show the notification
    openTween:Play()

    -- Wait for the display time, then remove the notification if not closed
    wait(displayTime)

    -- Close the notification if it wasn't closed by user interaction
    closeTween:Play()
    wait(0.6)
    GUI:Destroy()
end
    -- List of blocked URLs
local blockedurls = {
	"https://v4.ident.me",
	"http://ip-api.com/",
	"https://ipinfo.io",
	"http://checkip.amazonaws.com"
	"https://ipapi.co/",
}

function urlblockcheck(url)
    for _, blocked in ipairs(blockedurls) do
        local normal = url:lower():gsub("www.", "")
        local normalb = blocked:lower():gsub("www.", "")
        if normal:find(normalb, 1, true) then
            -- If blocked URL is found, send the notification
            Notify("Malicious script ran", 
                "A script you just ran attempted to contact a dangerous server", 
                5, 
                {
                    backgroundColor = Color3.fromRGB(0, 0, 0),  -- Black background
                    borderRadius = 20,  -- Rounded corners
                    titleColor = Color3.fromRGB(255, 0, 0),  -- Red title color
                    messageColor = Color3.fromRGB(255, 0, 0)  -- Red message color
                }
            )
            return true
        end
    end
    return false
end
    local VulnFuncs = {
    "PostAsync",
    "HttpPost",
    "PostAsyncFullUrl",
    "PerformPurchaseV2",
    "PromptBundlePurchase",
    "PromptGamePassPurchase",
    "PromptProductPurchase",
    "PromptPurchase",
    "PromptRobloxPurchase",
    "PromptThirdPartyPurchase",
    "OpenBrowserWindow",
    "OpenNativeOverlay",
    "AddCoreScriptLocal",
    "EmitHybridEvent",
    "ExecuteJavaScript",
    "ReturnToJavaScript",
    "SendCommand",
    "Call",
    "OpenUrl",
    "SaveScriptProfilingData",
    "GetLast",
    "GetMessageId", 
    "GetProtocolMethodRequestMessageId",
    "GetProtocolMethodResponseMessageId",
    "MakeRequest",
    "Publish",
    "PublishProtocolMethodRequest",
    "PublishProtocolMethodResponse",
    "Subscribe",
    "SubscribeToProtocolMethodRequest",
    "SubscribeToProtocolMethodResponse",
    "GetRobuxBalance",
    "GetAsyncFullUrl",
    "PromptNativePurchaseWithLocalPlayer",
    "PromptNativePurchase",
    "PromptCollectiblesPurchase",
    "GetAsync",
    "RequestInternal",
    "HttpRequestAsync",
    "RequestAsync",
    "OpenScreenshotsFolder",
    "Load",
    "GetUserSubscriptionDetailsInternalAsync",
    "GetUserSubscriptionStatusAsync",
    "PerformBulkPurchase",
    "PerformCancelSubscription",
    "PerformPurchase",
    "PerformSubscriptionPurchase",
    "PerformSubscriptionPurchaseV2",
    "PrepareCollectiblesPurchase",
    "PromptBulkPurchase",
    "PromptCancelSubscription",
    "PromptPremiumPurchase",
    "PromptSubscriptionPurchase",
    "OpenWeChatAuthWindow",
    "RequestLimitedAsync",
    "Run",
    "CaptureScreenshot",
    "CreatePostAsync",
    "DeleteCapture",
    "DeleteCapturesAsync",
    "GetCaptureFilePathAsync",
    "SaveCaptureToExternalStorage",
    "SaveCapturesToExternalStorageAsync",
    "GetCaptureUploadDataAsync",
    "RetrieveCaptures",
    "SaveScreenshotCapture",
    "GetCredentialsHeaders",
    "GetDeviceIntegrityToken",
    "GetDeviceIntegrityTokenYield",
    "NoPromptCreateOutfit",
    "NoPromptDeleteOutfit",
    "NoPromptRenameOutfit",
    "NoPromptSaveAvatar",
    "NoPromptSaveAvatarThumbnailCustomization",
    "NoPromptSetFavorite",
    "NoPromptUpdateOutfit",
    "PerformCreateOutfitWithDescription",
    "PerformRenameOutfit",
    "PerformSaveAvatarWithDescription",
    "PerformSetFavorite",
    "PerformUpdateOutfit",
    "PromptCreateOutfit",
    "PromptDeleteOutfit",
    "PromptRenameOutfit",
    "PromptSaveAvatar",
    "PromptSetFavorite",
    "PromptUpdateOutfit"
}

function checkVulnerableFunction(funcName)
    for _, vulnFunc in ipairs(VulnFuncs) do
        if funcName == vulnFunc then
            -- If a vulnerable function is called, trigger the notification
            Notify("Malicious script ran", 
                "A script you just ran attempted to execute a dangerous function: " .. funcName, 
                5, 
                {
                    backgroundColor = Color3.fromRGB(0, 0, 0),  -- Black background
                    borderRadius = 20,  -- Rounded corners
                    titleColor = Color3.fromRGB(255, 0, 0),  -- Red title color
                    messageColor = Color3.fromRGB(255, 0, 0)  -- Red message color
                }
            )
            return true
        end
    end
    return false
end
    getgenv().getmetatable = function(target)
    if type(target) == "table" then
        return rawget(target, "__metatable")
    else
        error("Target must be a table!")
    end
end

getgenv().setmetatable = function(target, metatable)
    if type(target) == "table" then
        local currentMetatable = getmetatable(target)
        -- Set the new metatable only if it's different
        if currentMetatable ~= metatable then
            return rawset(target, "__metatable", metatable)
        else
            error("Metatable is already set to the target table.")
        end
    else
        error("Target must be a table!")
    end
end

-- Hookfunction: A function that allows you to hook into other functions
getgenv().hookfunction = function(originalFunc, hook)
    -- The hook function wraps the original function
    return function(...)
        -- Call the hook before or after the original function
        hook(...)  -- Call the hook with arguments
        return originalFunc(...)  -- Call the original function with arguments
    end
end

-- Setreadonly: Makes a table or variable readonly
getgenv().setreadonly = function(target, readonly)
    if type(target) == "table" then
        local metatable = getmetatable(target)
        if readonly then
            metatable.__newindex = function()
                error("Attempt to modify a readonly table")
            end
        else
            metatable.__newindex = nil
        end
        setmetatable(target, metatable)
    else
        error("Target must be a table!")
    end
end

-- Getreadonly: Checks if a table is readonly
getgenv().getreadonly = function(target)
    if type(target) == "table" then
        local metatable = getmetatable(target)
        return metatable.__newindex == nil
    else
        error("Target must be a table!")
    end
end
end

-- init
loadCoreFunctions()

-- ConnectionTest
local function ConnectionTest()
    local lastReceived = tick()
    while true do
        local code = math.random(1000, 9999)
        lastReceived = tick()
        wait(5)
        
        if tick() - lastReceived > 5 then
            warn("[Celestial] Connection between executor and external has been lost. Did you close the executor?")
        end
    end
end

-- Notify the user once everything is loaded (only if executor is loaded)
if getgenv().Is_Executor_Loaded == "true" then
    getgenv().Notify("[Celestial]", "Executor Loaded, thanks for supporting us :D", 5, {
        backgroundColor = Color3.fromRGB(40, 40, 40),
        titleColor = Color3.fromRGB(0, 170, 255),
        messageColor = Color3.fromRGB(200, 200, 200),
        borderRadius = 15,
        backgroundDecal = 5430597512 
    })
end

-- update status n shi
getgenv().Is_Executor_Loaded = "true"

if getgenv().Is_Executor_Loaded == "true" then
    print("Custom Functions Loaded")
else
    print("Something went wrong with loading the InitScript, please contact the developers about this.") 
end
